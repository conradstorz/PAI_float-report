""" Monitor the system download folder for new float reports and process.
a sample filename is: Terminal Status(w_FLOAT)automated - 20190822.csv
This example is for the automated report generated by my processor. 
The first part of the name matches what I labeled the report in their system. 
The last part is the date of the report and was tagged on by the processor.
"""

import os
import csv
from time import sleep
from loguru import logger

# constants
bank_statement_basefilename = "BankDepositsStatement"

runtime_name = os.path.basename(__file__)

file_type = ".csv"
inputfile_extension = file_type

download_drive = "C:"
download_user_base = "Users"
download_user = "Conrad"
download_dir = "Downloads"
download_path = "C:/Users/Conrad/Downloads/"

floatReport_base_filename = "Terminal Status(w_FLOAT)automated"
output_dir = "Documents"
output_path = "C:/Users/Conrad/" + output_dir


@logger.catch
def process_csv(out_f, in_f, rundate):
    """Scan file and compute sums for 2 columns
    """
    balances = []
    floats = []
    terminals = 0
    with open(out_f, "w", newline="") as out_csv:  # supress extra newlines
        csvWriter = csv.writer(out_csv)
        with open(in_f) as csvDataFile:
            csvReader = csv.reader(csvDataFile)
            logger.debug(csvReader)
            for row in csvReader:
                logger.debug(row)
                csvWriter.writerow(row)
                if row[0] == "Terminal":
                    logger.debug('Located headers. Discarding...')
                else:
                    logger.debug('Adding terminal stats to running total.')
                    terminals += 1 # increment number of terminals reporting                    
                    if row[2] == '':
                        logger.debug('Terminal has no balance value. Adding Zero to balance list')
                        balances.append(0)
                    else:
                        balances.append(int(float(row[2].strip("$").replace(',',''))))
                    if row[3] == "":
                        logger.debug('Terminal has no float value. Adding Zero to floats list')
                        floats.append(0)
                    else:
                        logger.debug('adding ' + row[3] + ' to floats list.')
                        floats.append(int(float(row[3].strip("$").replace(',',''))))
            # gather results into tuple
            result = tuple(
                ["ATM", "VAULTS:", sum(balances), sum(floats), " = PAI FLOAT"]
            )
            logger.info(result)
            logger.info('Writing output to: ' + out_f)
            csvWriter.writerow(result)
            csvWriter.writerow([rundate, "...with", terminals, " terminals reporting"])
    return


@logger.catch
def extract_date(fname):
    """ the filename contains the date the report was run
    extract and return the date string
    """
    logger.info("Processing: " + fname)
    # sample filename string "Terminal Status(w_FLOAT)automated - 20190822.csv"
    fn = os.path.splitext(fname)[0]
    datestring = fn[-8:]
    return datestring


@logger.catch
def look_for_new_csv(match):
    """ Get files and return any match
    """
    files = [f for f in os.listdir(download_path) if f.endswith(inputfile_extension)]
    num_of_files = str(len(files))
    logger.debug(files)
    for fname in files:
        if match in fname:
            logger.info("Matched filename: " + fname)
            return fname
    return ""


@logger.catch
def determine_output_filename(datestr, output_folder):
    if not os.path.exists(output_folder):  # check and create output folder
        os.makedirs(output_folder)  # TODO trap IOerrors

    dest_folder = output_folder + "/" + datestr
    if not os.path.exists(dest_folder):  # check and create date folder
        os.makedirs(dest_folder)  # TODO trap IOerrors

    newfilename = "".join([dest_folder, "_", floatReport_base_filename, file_type])
    # TODO check if name already exists and do not overwrite

    return newfilename


@logger.catch
def remove_file(file_path):
    logger.info("Attempting to remove old %s file..." % file_path)

    if os.path.exists(file_path):
        try:
            os.remove(file_path)
        except OSError as e:
            logger.warning("Error: %s - %s." % (e.file_path, e.strerror))
            # sys.exit(1)
        logger.info("Success removing %s" % file_path)
        return 1

    else:
        logger.info("Sorry, could not find %s file." % file_path)

    return 0


@logger.catch
def defineLoggers():
    logger.configure(
        handlers=[{"sink": os.sys.stderr, "level": "INFO"}]
    )  # this method automatically suppresses the default handler to modify the message level

    #    logger.add(
    #        os.sys.stderr,
    #        format="{time} {level} {message}",
    #        filter="my_module",  # creates an entry showing module name and source code line number
    #        level="INFO",
    #    )  # set a handler

    #    logger.add(
    #        runtime_name + ".log",
    #        format="{time:YYYY-MM-DD at HH:mm:ss} | {level} | {message}",
    #    )  # this establishes a file log that gets appended each time the program runs

    logger.add(
        #        runtime_name + "_{time}.log", format=">> <lvl>{message}</lvl>", level="INFO"
        runtime_name + "_{time}.log",
        level="DEBUG",  # above line would simplify output to message only
    )  # create a new log file for each run of the program
    return


@logger.catch
def Main():
    defineLoggers()
    logger.info("Program Start.")  # log the start of the program
    logger.info(runtime_name)
    logger.info("Scanning for download to process...")

    inputfile = ""
    while inputfile == "":
        inputfile = look_for_new_csv(bank_statement_basefilename)
        inputfile = look_for_new_csv(floatReport_base_filename)
        if inputfile != "":
            filedate = extract_date(inputfile)
            output_file = determine_output_filename(filedate, output_path)
            logger.debug(filedate)
            inputfile_fq = "".join([download_path, inputfile])
            process_csv(output_file, inputfile_fq, filedate)
            args = os.sys.argv
            if len(args) > 1 and args[1] == "-np":
                logger.info("bypassing print option due to '-np' option.")
                logger.info("bypassing file removal option due to '-np' option.")
                logger.info("exiting program due to '-np' option.")
            else:
                logger.info("Send processed file to printer...")
                os.startfile(output_file, "print")
                remove_file(inputfile_fq)
                inputfile = ""  # keep the program running looking for more files
        logger.info("Nothing found. Sleeping 10 seconds")
        sleep(10)
    return


if __name__ == "__main__":
    Main()
